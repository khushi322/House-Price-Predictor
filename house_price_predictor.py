# -*- coding: utf-8 -*-
"""House Price Predictor

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KscHYjRLdfG8H-UmpmmHRkDhl2m3H4b0
"""

# Install and enable required libraries
!pip install --upgrade plotly ipywidgets scikit-learn
from google.colab import output
output.enable_custom_widget_manager()

import sqlite3
import pandas as pd
import plotly.express as px
import ipywidgets as widgets
from IPython.display import display, clear_output
from sklearn.linear_model import LinearRegression
import numpy as np

# Initialize SQLite database with sample data
def init_db():
    try:
        conn = sqlite3.connect('houses.db')
        c = conn.cursor()
        c.execute('''CREATE TABLE IF NOT EXISTS houses
                     (id INTEGER PRIMARY KEY AUTOINCREMENT, size INTEGER, bedrooms INTEGER, location TEXT, price FLOAT)''')
        c.execute("SELECT COUNT(*) FROM houses")
        if c.fetchone()[0] == 0:
            sample_data = [
                (1200, 2, 'Urban', 200000),
                (1500, 3, 'Suburban', 250000),
                (1000, 1, 'Rural', 150000),
                (1800, 4, 'Urban', 300000)
            ]
            c.executemany("INSERT INTO houses (size, bedrooms, location, price) VALUES (?, ?, ?, ?)", sample_data)
        conn.commit()
        conn.close()
        print("Database initialized.")
    except Exception as e:
        print(f"Error initializing database: {e}")

# Train a simple linear regression model
def train_model():
    X = np.array([[1200, 2, 1], [1500, 3, 0], [1000, 1, 2], [1800, 4, 1]])  # size, bedrooms, location (encoded)
    y = np.array([200000, 250000, 150000, 300000])  # prices
    model = LinearRegression()
    model.fit(X, y)
    return model

# Add a house and predict price
def add_house(size, bedrooms, location, model):
    try:
        # Encode location (simple mapping)
        location_map = {'Urban': 1, 'Suburban': 0, 'Rural': 2}
        features = np.array([[size, bedrooms, location_map[location]]])
        predicted_price = round(model.predict(features)[0], 2)
        predicted_price = max(100000, min(500000, predicted_price))  # Clamp to reasonable range
        conn = sqlite3.connect('houses.db')
        c = conn.cursor()
        c.execute("INSERT INTO houses (size, bedrooms, location, price) VALUES (?, ?, ?, ?)",
                  (size, bedrooms, location, predicted_price))
        conn.commit()
        conn.close()
        print(f"Added: {size} sqft, {bedrooms} bedrooms, {location}, Predicted Price: ${predicted_price:,.2f}")
        return predicted_price
    except Exception as e:
        print(f"Error adding house: {e}")
        return None

# Analyze houses
def analyze_houses():
    try:
        conn = sqlite3.connect('houses.db')
        df = pd.read_sql_query("SELECT * FROM houses", conn)
        conn.close()
        if not df.empty:
            print("Current Houses:")
            print(df[['size', 'bedrooms', 'location', 'price']])
        return df
    except Exception as e:
        print(f"Error loading houses: {e}")
        return pd.DataFrame()

# Display visualizations
def show_visualizations():
    df = analyze_houses()
    if df.empty:
        print("No houses to visualize!")
        return

    try:
        # Scatter plot: Size vs. Predicted Price
        fig_scatter = px.scatter(df, x='size', y='price', color='location', title='House Size vs. Predicted Price',
                                 labels={'size': 'Size (sqft)', 'price': 'Predicted Price ($)'},
                                 hover_data=['bedrooms'])
        fig_scatter.update_layout(width=600, height=400)
        fig_scatter.show()

        # Bar chart: Average price by location
        location_avg = df.groupby('location')['price'].mean().reset_index()
        fig_bar = px.bar(location_avg, x='location', y='price', title='Average Predicted Price by Location',
                         labels={'price': 'Average Price ($)'}, color='location')
        fig_bar.update_layout(width=600, height=400)
        fig_bar.show()

        # Summary statistics
        print(f"Total Houses: {len(df)}")
        print(f"Average Predicted Price: ${df['price'].mean():,.2f}")
    except Exception as e:
        print(f"Error generating visualizations: {e}")

# Create form
size_input = widgets.IntSlider(min=500, max=3000, step=50, value=1200, description="Size (sqft):")
bedrooms_input = widgets.IntSlider(min=1, max=5, step=1, value=2, description="Bedrooms:")
location_input = widgets.Dropdown(options=['Urban', 'Suburban', 'Rural'], description="Location:")
submit_button = widgets.Button(description="Add House", button_style='success')
viz_button = widgets.Button(description="Show Visualizations", button_style='info')

# Train model
model = train_model()

# Handle button clicks
def on_submit_clicked(b):
    clear_output()
    display(size_input, bedrooms_input, location_input, submit_button, viz_button)
    if size_input.value and bedrooms_input.value and location_input.value:
        add_house(size_input.value, bedrooms_input.value, location_input.value, model)
    else:
        print("Please fill all fields!")

def on_viz_clicked(b):
    clear_output()
    display(size_input, bedrooms_input, location_input, submit_button, viz_button)
    show_visualizations()

submit_button.on_click(on_submit_clicked)
viz_button.on_click(on_viz_clicked)

# Initialize and display
init_db()
display(size_input, bedrooms_input, location_input, submit_button, viz_button)